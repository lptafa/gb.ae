use "@/bus.ae"
use "@/utils.ae"

enum Reg {
    A, B, C, D, E, F, H, L
    AF, BC, DE, HL, SP, PC
}

def Reg::str(this): string => match this {
    A => "A"
    B => "B"
    C => "C"
    D => "D"
    E => "E"
    F => "F"
    H => "H"
    L => "L"
    AF => "AF"
    BC => "BC"
    DE => "DE"
    HL => "HL"
    SP => "SP"
    PC => "PC"
}

def Reg::from_bits(bits: u8): Reg => match bits {
    0x00u8 => Reg::B
    0x01u8 => Reg::C
    0x02u8 => Reg::D
    0x03u8 => Reg::E
    0x04u8 => Reg::H
    0x05u8 => Reg::L
    0x06u8 => Reg::HL
    0x07u8 => Reg::A
    else => {
        println("Invalid value in Reg::from_bits: 0x%02x", bits)
        exit(1)
    }
}

enum Cond {
    None
    NZ
    Z
    NC
    C
}

def Cond::str(this): string => match this {
    None => "None"
    NZ => "NZ"
    Z => "Z"
    NC => "NC"
    C => "C"
}

struct CPURegisters {
    a: u8
    f: u8
    b: u8
    c: u8
    d: u8
    e: u8
    h: u8
    l: u8
    pc: u16
    sp: u16
}

def CPURegisters::af(&this): u16 => (.a as u16 << 8u16) | .f as u16
def CPURegisters::bc(&this): u16 => (.b as u16 << 8u16) | .c as u16
def CPURegisters::de(&this): u16 => (.d as u16 << 8u16) | .e as u16
def CPURegisters::hl(&this): u16 => (.h as u16 << 8u16) | .l as u16

def CPURegisters::set_af(&this, val: u16) {
    .a = (val >> 8u16) as u8
    .f = val as u8
}

def CPURegisters::set_bc(&this, val: u16) {
    .b = (val >> 8u16) as u8
    .c = val as u8
}

def CPURegisters::set_de(&this, val: u16) {
    .d = (val >> 8u16) as u8
    .e = val as u8
}

def CPURegisters::set_hl(&this, val: u16) {
    .h = (val >> 8u16) as u8
    .l = val as u8
}

def CPURegisters::get8(&this, reg: Reg): u8 => match reg {
    A => .a
    B => .b
    C => .c
    D => .d
    E => .e
    F => .f
    H => .h
    L => .l
    else => { panic(`Called CPURegisters::get8 with invalid register type: Reg::{reg.str()}`) }
}

def CPURegisters::get16(&this, reg: Reg): u16 => match reg {
    AF => .af()
    BC => .bc()
    DE => .de()
    HL => .hl()
    SP => .sp
    PC => .pc
    else => { panic(`Called CPURegisters::get16 with invalid register type: Reg::{reg.str()}`) }
}

def CPURegisters::set8(&this, reg: Reg, val: u8) {
    match reg {
        A => .a = val
        B => .b = val
        C => .c = val
        D => .d = val
        E => .e = val
        F => .f = val
        H => .h = val
        L => .l = val
        else => { panic(`Called CPURegisters::set8 with invalid register type: Reg::{reg.str()}`) }
    }
}

def CPURegisters::set16(&this, reg: Reg, val: u16) {
    match reg {
        AF => .set_af(val)
        BC => .set_bc(val)
        DE => .set_de(val)
        HL => .set_hl(val)
        SP => .sp = val
        PC => .pc = val
        else => { panic(`Called CPURegisters::set16 with invalid register type: Reg::{reg.str()}`) }
    }
}

struct CPU {
    bus: &Bus
    regs: CPURegisters
    clock: u64

    ime: bool
    halted: bool

    reg_ie: u8
    reg_if: u8
}

def CPU::new(bus: &Bus): &CPU {
    let cpu = calloc(1, sizeof(CPU)) as &CPU
    cpu.bus = bus
    cpu.regs.pc = 0x100u16
    cpu.regs.a = 0x01u8
    cpu.ime = false
    return cpu
}

def CPU::flag_z(&this): bool => get_bit_u8(.regs.f, 7u8)
def CPU::set_flag_z(&this, val: bool) { set_bit_u8(&.regs.f, 7u8, val) }

def CPU::flag_n(&this): bool => get_bit_u8(.regs.f, 6u8)
def CPU::set_flag_n(&this, val: bool) { set_bit_u8(&.regs.f, 6u8, val) }

def CPU::flag_h(&this): bool => get_bit_u8(.regs.f, 5u8)
def CPU::set_flag_h(&this, val: bool) { set_bit_u8(&.regs.f, 5u8, val) }

def CPU::flag_c(&this): bool => get_bit_u8(.regs.f, 4u8)
def CPU::set_flag_c(&this, val: bool) { set_bit_u8(&.regs.f, 4u8, val) }

def CPU::read(&this, addr: u16): u8 => .bus.read(addr)

def CPU::write(&this, addr: u16, data: u8) {
    .bus.write(addr, data)
}

def CPU::read_u16(&this, addr: u16): u16 {
    let lo = .read(addr) as u16
    let hi = .read(addr + 1u16) as u16
    return (hi << 8u16) | lo
}

def CPU::set_flags(&this, zero: i32, sub: i32, half_carry: i32, carry: i32) {
    if zero != -1       then .set_flag_z(zero as bool)
    if sub != -1        then .set_flag_n(sub as bool)
    if half_carry != -1 then .set_flag_h(half_carry as bool)
    if carry != -1      then .set_flag_c(carry as bool)
}

def CPU::push_reg8(&this, reg: Reg) {
    let val = .regs.get8(reg)
    .regs.sp -= 1u16
    .write(.regs.sp, val)
}

def CPU::push_r16(&this, reg: Reg) {
    let val = .regs.get16(reg)
    .regs.sp -= 1u16
    .write(.regs.sp, (val >> 8u16) as u8)
    .regs.sp -= 1u16
    .write(.regs.sp, val as u8)
}

const DEBUG = true

def CPU::op_nop(&this) {
    if DEBUG println("NOP")

    .clock += 4u64
    .regs.pc += 1u16
}

def CPU::op_jmp(&this, cond: Cond) {
    let addr = .read_u16(.regs.pc + 1u16)
    if cond == Cond::None {
        if DEBUG println("JP $%04x", addr)
    } else {
        if DEBUG println("JP %s, $%04x", cond.str(), addr)
    }

    let should_jump = match cond {
        Cond::None => true
        Cond::NZ => not .flag_z()
        Cond::Z => .flag_z()
        Cond::NC => not .flag_c()
        Cond::C => .flag_c()
    }

    if should_jump {
        .regs.pc = addr
        .clock += 16u64
    } else {
        .regs.pc += 3u16
        .clock += 12u64
    }
}

def CPU::op_jmp_rel(&this, cond: Cond) {
    let offset = .read(.regs.pc + 1u16) as i8
    if cond == Cond::None {
        if DEBUG println("JR $%02x", offset as u8)
    } else {
        if DEBUG println("JR %s, $%02x", cond.str(), offset as u8)
    }

    let should_jump = match cond {
        Cond::None => true
        Cond::NZ => not .flag_z()
        Cond::Z => .flag_z()
        Cond::NC => not .flag_c()
        Cond::C => .flag_c()
    }

    .regs.pc += 2u16
    if should_jump {
        .clock += 12u64
        .regs.pc = (.regs.pc as i16 + offset as i16) as u16
    } else {
        .clock += 8u64
    }
}

// Note for `EI`: (https://gbdev.io/pandocs/Interrupts.html)
//  > The effect of ei is delayed by one instruction. This means that ei followed
//  > immediately by di does not allow any interrupts between them. This interacts
//  > with the halt bug in an interesting way.

def CPU::op_di(&this) {
    if DEBUG println("DI")

    .ime = false

    .clock += 4u64
    .regs.pc += 1u16
}

def CPU::op_ld_r_r(&this, dst: Reg, src: Reg) {
    // Load register into register
    if DEBUG println("LD %s, %s", dst.str(), src.str())

    let val = .regs.get8(src)
    .regs.set8(dst, val)

    .clock += 4u64
    .regs.pc += 1u16
}

def CPU::op_ld_r_hl(&this, dst: Reg) {
    // Load (HL) into register
    if DEBUG println("LD %s, (HL)", dst.str())

    let val = .read(.regs.hl())
    .regs.set8(dst, val)

    .clock += 8u64
    .regs.pc += 1u16
}

def CPU::op_ld_hl_r(&this, src: Reg) {
    // Load register into (HL)
    let val = .regs.get8(src)
    if DEBUG println("LD (HL), %s [%02X]", src.str(), val)

    .write(.regs.hl(), val)

    .clock += 8u64
    .regs.pc += 1u16
}

def CPU::op_ld_imm_a(&this) {
    // Load A into immediate
    let addr = .read_u16(.regs.pc + 1u16)
    if DEBUG println("LD ($%04X), A", addr)

    .write(addr, .regs.a)

    .clock += 16u64
    .regs.pc += 3u16
}

def CPU::op_ld_r16_imm(&this, dst: Reg) {
    let val = .read_u16(.regs.pc + 1u16)
    if DEBUG println("LD %s, $%04X", dst.str(), val)

    .regs.set16(dst, val)

    .clock += 12u64
    .regs.pc += 3u16
}

def CPU::op_ld_r_imm(&this, dest: Reg) {
    let val = .read(.regs.pc + 1u16)
    if DEBUG println("LD %s, $%02X", dest.str(), val)

    .regs.set8(dest, val)

    .clock += 8u64
    .regs.pc += 2u16
}

def CPU::op_ld_ff00n_a(&this) {
    let n = .read(.regs.pc + 1u16)
    if DEBUG println("LD (FF00+$%02X), A", n)

    let addr = 0xFF00u16 | (n as u16)
    .write(addr, .regs.a)

    .clock += 12u64
    .regs.pc += 2u16
}

def CPU::op_ld_a_ff00n(&this) {
    let n = .read(.regs.pc + 1u16)
    if DEBUG println("LD A, (FF00+$%02X)", n)

    let addr = 0xFF00u16 | (n as u16)
    .regs.a = .read(addr)

    .clock += 12u64
    .regs.pc += 2u16
}

def CPU::op_ld_ff00c_a(&this) {
    let addr = 0xFF00u16 | (.regs.c as u16)
    if DEBUG println("LD (FF00+C [%04X]), A", addr)

    .write(addr, .regs.a)

    .clock += 8u64
    .regs.pc += 1u16
}

def CPU::op_ld_a_ff00c(&this) {
    let addr = 0xFF00u16 | (.regs.c as u16)
    if DEBUG println("LD A, (FF00+C [%04x])", addr)

    .regs.a = .read(addr)

    .clock += 8u64
    .regs.pc += 1u16
}

def CPU::op_ldi_hl_a(&this, inc: i16) {
    if inc > 0i16 {
        if DEBUG println("LDI (HL), A")
    } else {
        if DEBUG println("LDD (HL), A")
    }

    .write(.regs.hl(), .regs.a)

    let new_hl = ((.regs.hl() as i16) + inc) as u16
    .regs.set_hl(new_hl)

    .clock += 8u64
    .regs.pc += 1u16
}

def CPU::op_ldi_a_hl(&this, inc: i16) {
    if inc > 0i16 {
        if DEBUG println("LDI A, (HL)")
    } else {
        if DEBUG println("LDD A, (HL)")
    }

    .regs.a = .read(.regs.hl())

    let new_hl = ((.regs.hl() as i16) + inc) as u16
    .regs.set_hl(new_hl)

    .clock += 8u64
    .regs.pc += 1u16
}

def CPU::op_ld_a_imm16(&this) {
    let addr = .read_u16(.regs.pc + 1u16)
    if DEBUG println("LD A, ($%04X)", addr)

    .regs.a = .read(addr)

    .clock += 16u64
    .regs.pc += 3u16
}

def CPU::op_ld_r_r16(&this, dst: Reg, src: Reg) {
    let addr = .regs.get16(src)
    if DEBUG println("LD %s, (%s [%04X])", dst.str(), src.str(), addr)

    .regs.set8(dst, .read(addr))

    .clock += 8u64
    .regs.pc += 1u16
}

def CPU::op_push16(&this, src: Reg) {
    // Push 16-bit register onto stack
    if DEBUG println("PUSH %s", src.str())

    .push_r16(src)

    .clock += 16u64
    .regs.pc += 1u16
}

def CPU::op_pop16(&this, dst: Reg) {
    // Pop 16-bit register from stack
    if DEBUG println("POP %s", dst.str())

    let val = .read_u16(.regs.sp)
    .regs.set16(dst, val)
    .regs.sp += 2u16

    .clock += 12u64
    .regs.pc += 1u16
}

def CPU::op_alu_r(&this, handler: fn(&CPU, u8), src: Reg) {
    if src == Reg::HL {
        let val = .read(.regs.hl())
        handler(this, val)
        if DEBUG println(" (HL [%02X])", val)
        .clock += 8u64
    } else {
        let val = .regs.get8(src)
        handler(this, val)
        if DEBUG println(" %s [%02X]", src.str(), val)
        .clock += 4u64
    }
    .regs.pc += 1u16
}

def CPU::op_alu_imm(&this, handler: fn(&CPU, u8)) {
    let val = .read(.regs.pc + 1u16)

    handler(this, val)
    if DEBUG println(" $%02X", val)

    .clock += 8u64
    .regs.pc += 2u16
}

def CPU::op_inc_r16(&this, reg: Reg, offset: i16) {
    // Increment 16-bit register
    if offset > 0i16 {
        if DEBUG println("INC %s", reg.str())
    } else {
        if DEBUG println("DEC %s", reg.str())
    }

    let val = .regs.get16(reg)
    let new_val = ((val as i16) + offset) as u16
    .regs.set16(reg, new_val)

    .clock += 8u64
    .regs.pc += 1u16
}

def CPU::op_inc_r(&this, reg: Reg, offset: i8) {
    // Increment 8-bit register
    if offset > 0i8 {
        if DEBUG println("INC %s", reg.str())
    } else {
        if DEBUG println("DEC %s", reg.str())
    }

    let prev = .regs.get8(reg) as i8
    let val = (prev + offset) as u8
    .regs.set8(reg, val)

    .set_flag_z(val == 0u8)
    .set_flag_n(offset < 0i8)
    .set_flag_h((val & 0x0Fu8) == 0x00u8)

    .clock += 4u64
    .regs.pc += 1u16
}

def CPU::op_inc_mem_hl(&this, offset: i8) {
    // Increment memory at (HL)
    if offset > 0i8 {
        if DEBUG println("INC (HL)")
    } else {
        if DEBUG println("DEC (HL)")
    }

    let val = .read(.regs.hl()) as i8
    let result = (val + offset) as u8
    .write(.regs.hl(), result)

    .set_flag_z(result == 0u8)
    .set_flag_n(offset < 0i8)
    .set_flag_h((val & 0x0Fi8) == 0i8)

    .clock += 12u64
    .regs.pc += 1u16
}

def CPU::op_halt(&this) {
    if DEBUG println("HALT")

    .halted = true

    .clock += 4u64
    .regs.pc += 1u16
}

def CPU::op_call(&this, cond: Cond) {
    let addr = .read_u16(.regs.pc + 1u16)
    if cond == Cond::None {
        if DEBUG println("CALL $%04X", addr)
    } else {
        if DEBUG println("CALL %s, $%04X", cond.str(), addr)
    }

    let should_call = match cond {
        Cond::None => true,
        Cond::NZ => not .flag_z(),
        Cond::Z => .flag_z(),
        Cond::NC => not .flag_c(),
        Cond::C => .flag_c(),
    }

    .regs.pc += 3u16
    if should_call {
        .push_r16(Reg::PC)
        .clock += 24u64
        .regs.pc = addr
    } else {
        .clock += 12u64
    }
}

def CPU::op_ret(&this, cond: Cond) {
    if cond == Cond::None {
        if DEBUG println("RET")
    } else {
        if DEBUG println("RET %s", cond.str())
    }

    let should_jump = match cond {
        Cond::None => true,
        Cond::NZ => not .flag_z(),
        Cond::Z => .flag_z(),
        Cond::NC => not .flag_c(),
        Cond::C => .flag_c(),
    }

    if should_jump {
        let ret_addr = .read_u16(.regs.sp)
        .regs.sp += 2u16

        if cond == Cond::None {
            .clock += 16u64
        } else {
            .clock += 20u64
        }
        .regs.pc = ret_addr
    } else {
        .clock += 8u64
        .regs.pc += 1u16
    }
}

def CPU::op_rrca(&this) {
    if DEBUG println("RRCA")
    let val = .regs.a
    let new_c = val & 1u8
    let res = (val >> 1u8) | (new_c << 7u8)

    .set_flag_z(val == 0u8)
    .set_flag_n(false)
    .set_flag_h(false)
    .set_flag_c(new_c == 1u8)

    .regs.a = res
    .clock += 4u64
    .regs.pc += 1u16
}

def CPU::op_rra(&this) {
    if DEBUG println("RRA")
    let val = .regs.a
    let carry = .flag_c() as u8
    let new_c = val & 1u8
    let res = (val >> 1u8) | (new_c << 7u8)

    .set_flag_z(val == 0u8)
    .set_flag_n(false)
    .set_flag_h(false)
    .set_flag_c(new_c == 1u8)

    .regs.a = res
    .clock += 4u64
    .regs.pc += 1u16
}

// This is a hack to get around the fact that we can't pass
// unbound methods

def ALU_CP(cpu: &CPU, val: u8) {
    if DEBUG print("CP")
    // This is a hack to avoid sign-extending
    let a = (cpu.regs.a as u16) as i16
    let b = (val as u16) as i16
    let result = a - b

    cpu.set_flag_z(result == 0i16)
    cpu.set_flag_n(true)
    cpu.set_flag_h((a & 0xFi16) - (b & 0xFi16) < 0i16)
    cpu.set_flag_c(result < 0i16)
}

def ALU_AND(cpu: &CPU, val: u8) {
    if DEBUG print("AND")
    let result = cpu.regs.a & val

    cpu.set_flag_z(result == 0u8)
    cpu.set_flag_n(false)
    cpu.set_flag_h(true)
    cpu.set_flag_c(false)

    cpu.regs.a = result
}

def ALU_OR(cpu: &CPU, val: u8) {
    if DEBUG print("OR")
    let result = cpu.regs.a | val

    cpu.set_flag_z(result == 0u8)
    cpu.set_flag_n(false)
    cpu.set_flag_h(false)
    cpu.set_flag_c(false)

    cpu.regs.a = result
}

def ALU_XOR(cpu: &CPU, val: u8) {
    if DEBUG print("XOR")
    let result = cpu.regs.a ^ val

    cpu.set_flag_z(result == 0u8)
    cpu.set_flag_n(false)
    cpu.set_flag_h(false)
    cpu.set_flag_c(false)

    cpu.regs.a = result
}


def ALU_ADD(cpu: &CPU, val: u8) {
    if DEBUG print("ADD")
    let a = cpu.regs.a as u16
    let b = val as u16
    let result = a + b

    cpu.set_flag_z(result == 0u16)
    cpu.set_flag_n(false)
    cpu.set_flag_h((a & 0xFu16) + (b & 0xFu16) > 0xFu16)
    cpu.set_flag_c(result > 0xFFu16)

    cpu.regs.a = result as u8
}

def ALU_ADDC(cpu: &CPU, val: u8) {
    if DEBUG print("ADDC")
    let a = cpu.regs.a as u16
    let b = val as u16
    let c = cpu.flag_c() as u16
    let result = a + b + c

    cpu.set_flag_z(result == 0u16)
    cpu.set_flag_n(false)
    cpu.set_flag_h((a & 0xFu16) + (b & 0xFu16) + c > 0xFu16)
    cpu.set_flag_c(result > 0xFFu16)

    cpu.regs.a = result as u8
}

def ALU_SUB(cpu: &CPU, val: u8) {
    // FIXME: is stuff breaking here becuase of the signed/unsigned types?
    if DEBUG print("SUB")
    let a = cpu.regs.a as i16
    let b = val as i16
    let result = a - b

    cpu.set_flag_z(result == 0i16)
    cpu.set_flag_n(true)
    cpu.set_flag_h((a & 0xFi16) - (b & 0xFi16) < 0i16)
    cpu.set_flag_c(result < 0i16)

    cpu.regs.a = result as u8
}

def CPU::op_bit(&this, bit: u8, reg: Reg) {
    if DEBUG println("BIT %d, %s", bit, reg.str())

    let val = if reg == Reg::HL {
        .clock += 12u64
        yield .read(.regs.hl())
    } else {
        .clock += 8u64
        yield .regs.get8(reg)
    }

    .set_flag_z(get_bit_u8(val, bit))
    .set_flag_n(false)
    .set_flag_h(true)

    .regs.pc += 2u16
}


def CPU::op_set_bit(&this, bit: u8, reg: Reg, val: bool) {
    if val {
        if DEBUG println("SET %d, %s", bit, reg.str())
    } else {
        if DEBUG println("RES %d, %s", bit, reg.str())
    }

    if reg == Reg::HL {
        let mem = .read(.regs.hl())
        set_bit_u8(&mem, bit, val)
        .write(.regs.hl(), mem)
        .clock += 16u64
        .regs.pc += 2u16

    } else {
        let mem = .regs.get8(reg)
        set_bit_u8(&mem, bit, val)
        .regs.set8(reg, mem)
        .clock += 8u64
        .regs.pc += 2u16
    }
}

def CPU::op_rlc(&this, reg: Reg) {
    if DEBUG println("RLC %s [UNIMPLEMENTED]", reg.str())
    exit(1)
}

def CPU::op_rl(&this, reg: Reg) {
    if DEBUG println("RL %s [UNIMPLEMENTED]", reg.str())
    exit(1)
}

def CPU::op_rrc(&this, reg: Reg) {
    if DEBUG println("RRC %s", reg.str())
    let val = match reg {
        HL => .read(.regs.hl())
        else => .regs.get8(reg)
    }
    let new_c = val & 1u8
    let res = (val >> 1u8) | (new_c << 7u8)

    .set_flag_z(val == 0u8)
    .set_flag_n(false)
    .set_flag_h(false)
    .set_flag_c(new_c == 1u8)

    if reg == Reg::HL {
        .write(.regs.hl(), res)
        .clock += 16u64
    } else {
        .regs.set8(reg, res)
        .clock += 8u64
    }
    .regs.pc += 2u16
}

def CPU::op_rr(&this, reg: Reg) {
    if DEBUG println("RR %s [UNIMPLEMENTED]", reg.str())
    let val = match reg {
        HL => .read(.regs.hl())
        else => .regs.get8(reg)
    }
    let carry = .flag_c() as u8
    let new_c = val & 1u8
    let res = (val >> 1u8) | (new_c << 7u8)

    .set_flag_z(val == 0u8)
    .set_flag_n(false)
    .set_flag_h(false)
    .set_flag_c(new_c == 1u8)

    if reg == Reg::HL {
        .write(.regs.hl(), res)
        .clock += 16u64
    } else {
        .regs.set8(reg, res)
        .clock += 8u64
    }
    .regs.pc += 2u16
}

def CPU::op_sla(&this, reg: Reg) {
    if DEBUG println("SLA %s [UNIMPLEMENTED]", reg.str())
    exit(1)
}

def CPU::op_sra(&this, reg: Reg) {
    if DEBUG println("SRA %s", reg.str())
    let val = match reg {
        HL => .read(.regs.hl())
        else => .regs.get8(reg)
    }

    let res = (val >> 1u8) | (val & 0x80u8)
    .set_flag_z(res == 0u8)
    .set_flag_n(false)
    .set_flag_h(false)
    .set_flag_c(val & 0x1u8 != 0u8)

    if reg == Reg::HL {
        .write(.regs.hl(), res)
        .clock += 16u64
    } else {
        .regs.set8(reg, res)
        .clock += 8u64
    }
    .regs.pc += 2u16
}

def CPU::op_swap(&this, reg: Reg) {
    if DEBUG println("SWAP %s [UNIMPLEMENTED]", reg.str())
    exit(1)
}

def CPU::op_srl(&this, reg: Reg) {
    if DEBUG println("SRL %s", reg.str())
    let val = match reg {
        HL => .read(.regs.hl())
        else => .regs.get8(reg)
    }

    let res = (val >> 1u8)
    .set_flag_z(res == 0u8)
    .set_flag_n(false)
    .set_flag_h(false)
    .set_flag_c(val & 0x1u8 != 0u8)

    if reg == Reg::HL {
        .write(.regs.hl(), res)
        .clock += 16u64
    } else {
        .regs.set8(reg, res)
        .clock += 8u64
    }
    .regs.pc += 2u16
}

def CPU::handle_cb_instruction(&this) {
    let cb_opcode = .read(.regs.pc + 1u16)
    if DEBUG print("(%02x): ", cb_opcode)

    let reg = Reg::from_bits(cb_opcode & 0b111u8)
    let bit = (cb_opcode >> 3u8) & 0b111u8 // Only for BIT, RES, SET

    match cb_opcode >> 4u8 {
        0x4u8 | 0x5u8 | 0x6u8 | 0x7u8 => .op_bit(bit, reg)
        0x8u8 | 0x9u8 | 0xau8 | 0xbu8  => {
            .op_set_bit(bit, reg, false)
        }
        0xcu8 | 0xdu8 | 0xeu8 | 0xfu8 => {
            let bit = (cb_opcode >> 3u8) & 0b111u8
            .op_set_bit(bit, reg, true)
        }
        else => match cb_opcode >> 3u8 {
            0x0u8 => .op_rlc(reg)
            0x1u8 => .op_rrc(reg)
            0x2u8 => .op_rl(reg)
            0x3u8 => .op_rr(reg)
            0x4u8 => .op_sla(reg)
            0x5u8 => .op_sra(reg)
            0x6u8 => .op_swap(reg)
            0x7u8 => .op_srl(reg)
            else => panic("Invalid CB opcode")
        }
    }
}

def CPU::handle_instruction(&this) {
    let opcode = .read(.regs.pc)
    if DEBUG print("0x%04x: (%02x): ", .regs.pc, opcode)
    match opcode {
        // 0x0y
        0x00u8 => .op_nop()
        0x01u8 => .op_ld_r16_imm(Reg::BC)

        0x03u8 => .op_inc_r16(Reg::BC, offset: 1i16)
        0x04u8 => .op_inc_r(Reg::B, offset: 1i8)
        0x05u8 => .op_inc_r(Reg::B, offset: -1i8)
        0x06u8 => .op_ld_r_imm(Reg::B)

        0x0cu8 => .op_inc_r(Reg::C, offset: 1i8)
        0x0du8 => .op_inc_r(Reg::C, offset: -1i8)
        0x0eu8 => .op_ld_r_imm(Reg::C)
        0x0fu8 => .op_rrca()

        // 0x1y
        0x11u8 => .op_ld_r16_imm(Reg::DE)

        0x13u8 => .op_inc_r16(Reg::DE, offset: 1i16)

        0x16u8 => .op_ld_r_imm(Reg::D)

        0x18u8 => .op_jmp_rel(Cond::None)

        0x1au8 => .op_ld_r_r16(dst: Reg::A, src: Reg::DE)

        0x1eu8 => .op_ld_r_imm(Reg::E)
        0x1fu8 => .op_rra()

        // 0x2y
        0x20u8 => .op_jmp_rel(Cond::NZ)
        0x21u8 => .op_ld_r16_imm(Reg::HL)
        0x22u8 => .op_ldi_hl_a(inc: 1i16)
        0x23u8 => .op_inc_r16(Reg::HL, offset: 1i16)
        0x24u8 => .op_inc_r(Reg::H, offset: 1i8)
        0x25u8 => .op_inc_r(Reg::H, offset: -1i8)
        0x26u8 => .op_ld_r_imm(Reg::H)

        0x28u8 => .op_jmp_rel(Cond::Z)

        0x2au8 => .op_ldi_a_hl(inc: 1i16)

        0x2cu8 => .op_inc_r(Reg::L, offset: 1i8)
        0x2du8 => .op_inc_r(Reg::L, offset: -1i8)
        0x2eu8 => .op_ld_r_imm(Reg::L)

        // 0x3y
        0x30u8 => .op_jmp_rel(Cond::NC)
        0x31u8 => .op_ld_r16_imm(Reg::SP)
        0x32u8 => .op_ldi_hl_a(inc: -1i16)
        0x33u8 => .op_inc_r16(Reg::SP, offset: 1i16)
        0x34u8 => .op_inc_mem_hl(offset: 1i8)
        0x35u8 => .op_inc_mem_hl(offset: -1i8)

        0x3au8 => .op_ldi_a_hl(inc: -1i16)

        0x3cu8 => .op_inc_r(Reg::A, offset: 1i8)
        0x3du8 => .op_inc_r(Reg::A, offset: -1i8)
        0x3eu8 => .op_ld_r_imm(Reg::A)

        // 0x4y
        0x40u8 => .op_ld_r_r(dst: Reg::B, src: Reg::B)
        0x41u8 => .op_ld_r_r(dst: Reg::B, src: Reg::C)
        0x42u8 => .op_ld_r_r(dst: Reg::B, src: Reg::D)
        0x43u8 => .op_ld_r_r(dst: Reg::B, src: Reg::E)
        0x44u8 => .op_ld_r_r(dst: Reg::B, src: Reg::H)
        0x45u8 => .op_ld_r_r(dst: Reg::B, src: Reg::L)
        0x46u8 => .op_ld_r_hl(dst: Reg::B)
        0x47u8 => .op_ld_r_r(dst: Reg::B, src: Reg::A)
        0x48u8 => .op_ld_r_r(dst: Reg::C, src: Reg::B)
        0x49u8 => .op_ld_r_r(dst: Reg::C, src: Reg::C)
        0x4au8 => .op_ld_r_r(dst: Reg::C, src: Reg::D)
        0x4bu8 => .op_ld_r_r(dst: Reg::C, src: Reg::E)
        0x4cu8 => .op_ld_r_r(dst: Reg::C, src: Reg::H)
        0x4du8 => .op_ld_r_r(dst: Reg::C, src: Reg::L)
        0x4eu8 => .op_ld_r_hl(Reg::C)
        0x4fu8 => .op_ld_r_r(dst: Reg::C, src: Reg::A)

        // 0x5y
        0x50u8 => .op_ld_r_r(dst: Reg::D, src: Reg::B)
        0x51u8 => .op_ld_r_r(dst: Reg::D, src: Reg::C)
        0x52u8 => .op_ld_r_r(dst: Reg::D, src: Reg::D)
        0x53u8 => .op_ld_r_r(dst: Reg::D, src: Reg::E)
        0x54u8 => .op_ld_r_r(dst: Reg::D, src: Reg::H)
        0x55u8 => .op_ld_r_r(dst: Reg::D, src: Reg::L)
        0x56u8 => .op_ld_r_hl(Reg::D)
        0x57u8 => .op_ld_r_r(dst: Reg::D, src: Reg::A)
        0x58u8 => .op_ld_r_r(dst: Reg::E, src: Reg::B)
        0x59u8 => .op_ld_r_r(dst: Reg::E, src: Reg::C)
        0x5au8 => .op_ld_r_r(dst: Reg::E, src: Reg::D)
        0x5bu8 => .op_ld_r_r(dst: Reg::E, src: Reg::E)
        0x5cu8 => .op_ld_r_r(dst: Reg::E, src: Reg::H)
        0x5du8 => .op_ld_r_r(dst: Reg::E, src: Reg::L)
        0x5eu8 => .op_ld_r_hl(Reg::E)
        0x5fu8 => .op_ld_r_r(dst: Reg::E, src: Reg::A)

        // 0x6y
        0x60u8 => .op_ld_r_r(dst: Reg::H, src: Reg::B)
        0x61u8 => .op_ld_r_r(dst: Reg::H, src: Reg::C)
        0x62u8 => .op_ld_r_r(dst: Reg::H, src: Reg::D)
        0x63u8 => .op_ld_r_r(dst: Reg::H, src: Reg::E)
        0x64u8 => .op_ld_r_r(dst: Reg::H, src: Reg::H)
        0x65u8 => .op_ld_r_r(dst: Reg::H, src: Reg::L)
        0x66u8 => .op_ld_r_hl(Reg::H)
        0x67u8 => .op_ld_r_r(dst: Reg::H, src: Reg::A)
        0x68u8 => .op_ld_r_r(dst: Reg::L, src: Reg::B)
        0x69u8 => .op_ld_r_r(dst: Reg::L, src: Reg::C)
        0x6au8 => .op_ld_r_r(dst: Reg::L, src: Reg::D)
        0x6bu8 => .op_ld_r_r(dst: Reg::L, src: Reg::E)
        0x6cu8 => .op_ld_r_r(dst: Reg::L, src: Reg::H)
        0x6du8 => .op_ld_r_r(dst: Reg::L, src: Reg::L)
        0x6eu8 => .op_ld_r_hl(Reg::L)
        0x6fu8 => .op_ld_r_r(dst: Reg::L, src: Reg::A)

        // 0x7y
        0x70u8 => .op_ld_hl_r(src: Reg::B)
		0x71u8 => .op_ld_hl_r(src: Reg::C)
		0x72u8 => .op_ld_hl_r(src: Reg::D)
		0x73u8 => .op_ld_hl_r(src: Reg::E)
		0x74u8 => .op_ld_hl_r(src: Reg::H)
		0x75u8 => .op_ld_hl_r(src: Reg::L)
		0x76u8 => .op_halt()
		0x77u8 => .op_ld_hl_r(src: Reg::A)
        0x78u8 => .op_ld_r_r(dst: Reg::A, src: Reg::B)
		0x79u8 => .op_ld_r_r(dst: Reg::A, src: Reg::C)
		0x7au8 => .op_ld_r_r(dst: Reg::A, src: Reg::D)
		0x7bu8 => .op_ld_r_r(dst: Reg::A, src: Reg::E)
		0x7cu8 => .op_ld_r_r(dst: Reg::A, src: Reg::H)
		0x7du8 => .op_ld_r_r(dst: Reg::A, src: Reg::L)
        0x7eu8 => .op_ld_r_hl(Reg::A)
        0x7fu8 => .op_ld_r_r(dst: Reg::A, src: Reg::A)

        // 0xay
        0xa8u8 => .op_alu_r(ALU_XOR, Reg::B)
        0xa9u8 => .op_alu_r(ALU_XOR, Reg::C)
        0xaau8 => .op_alu_r(ALU_XOR, Reg::D)
        0xabu8 => .op_alu_r(ALU_XOR, Reg::E)
        0xacu8 => .op_alu_r(ALU_XOR, Reg::H)
        0xadu8 => .op_alu_r(ALU_XOR, Reg::L)
        0xaeu8 => .op_alu_r(ALU_XOR, Reg::HL)
        0xafu8 => .op_alu_r(ALU_XOR, Reg::A)

        // 0xby
        0xb0u8 => .op_alu_r(ALU_OR, Reg::B)
        0xb1u8 => .op_alu_r(ALU_OR, Reg::C)
        0xb2u8 => .op_alu_r(ALU_OR, Reg::D)
        0xb3u8 => .op_alu_r(ALU_OR, Reg::E)
        0xb4u8 => .op_alu_r(ALU_OR, Reg::H)
        0xb5u8 => .op_alu_r(ALU_OR, Reg::L)
        0xb6u8 => .op_alu_r(ALU_OR, Reg::HL)
        0xb7u8 => .op_alu_r(ALU_OR, Reg::A)
        0xb8u8 => .op_alu_r(ALU_CP, Reg::B)
        0xb9u8 => .op_alu_r(ALU_CP, Reg::C)
        0xbau8 => .op_alu_r(ALU_CP, Reg::D)
        0xbbu8 => .op_alu_r(ALU_CP, Reg::E)
        0xbcu8 => .op_alu_r(ALU_CP, Reg::H)
        0xbdu8 => .op_alu_r(ALU_CP, Reg::L)
        0xbeu8 => .op_alu_r(ALU_CP, Reg::HL)
        0xbfu8 => .op_alu_r(ALU_CP, Reg::A)

        // 0xcy
        0xc0u8 => .op_ret(Cond::NZ)
        0xc1u8 => .op_pop16(Reg::BC)
        0xc3u8 => .op_jmp(Cond::None)
        0xc4u8 => .op_call(Cond::NZ)
        0xc5u8 => .op_push16(Reg::BC)
        0xc6u8 => .op_alu_imm(ALU_ADD)

        0xc9u8 => .op_ret(Cond::None)

        0xcbu8 => .handle_cb_instruction()

        0xcdu8 => .op_call(Cond::None)
        0xceu8 => .op_alu_imm(ALU_ADDC)

        // 0xdy
        0xd0u8 => .op_ret(Cond::NC)
        0xd1u8 => .op_pop16(Reg::DE)

        0xd5u8 => .op_push16(Reg::DE)
        0xd6u8 => .op_alu_imm(ALU_SUB)


        // 0xey
        0xe0u8 => .op_ld_ff00n_a()
        0xe1u8 => .op_pop16(Reg::HL)
        0xe2u8 => .op_ld_ff00c_a()

        0xe5u8 => .op_push16(Reg::HL)
        0xe6u8 => .op_alu_imm(ALU_AND)

        0xeau8 => .op_ld_imm_a()

        0xeeu8 => .op_alu_imm(ALU_XOR)

        // 0xfy
        0xf0u8 => .op_ld_a_ff00n()
        0xf1u8 => .op_pop16(Reg::AF)
        0xf2u8 => .op_ld_a_ff00c()
        0xf3u8 => .op_di()

        0xf5u8 => .op_push16(Reg::AF)

        0xfau8 => .op_ld_a_imm16()

        0xfeu8 => .op_alu_imm(ALU_CP)

        else => panic("Unknown opcode")
    }
}


def CPU::tick(&this): u64 {
    let prev_clock = .clock
    .handle_instruction()
    return prev_clock - .clock
}